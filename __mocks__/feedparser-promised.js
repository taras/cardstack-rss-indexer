const payload = `
<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Taras Mankovski on Medium]]></title>
        <description><![CDATA[Stories by Taras Mankovski on Medium]]></description>
        <link>https://medium.com/@tarasm?source=rss-eccf3ca48bae------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/0*Qf3J_9Q0r7FoFxpA.jpeg</url>
            <title>Stories by Taras Mankovski on Medium</title>
            <link>https://medium.com/@tarasm?source=rss-eccf3ca48bae------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Sat, 03 Jun 2017 09:11:19 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@tarasm" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[Ember comes packaged with architecture which has its benefits and tradeoffs.]]></title>
            <link>https://medium.com/@tarasm/ember-comes-packaged-with-architecture-which-has-its-benefits-and-tradeoffs-5c4de2275113?source=rss-eccf3ca48bae------2</link>
            <guid isPermaLink="false">https://medium.com/p/5c4de2275113</guid>
            <dc:creator><![CDATA[Taras Mankovski]]></dc:creator>
            <pubDate>Thu, 04 May 2017 20:26:04 GMT</pubDate>
            <atom:updated>2017-05-04T20:26:04.803Z</atom:updated>
            <content:encoded><![CDATA[<p>Ember comes packaged with architecture which has its benefits and tradeoffs. One benefit is that every app built with Ember is architected the same way. A tradeoff is that you have to know how something fits into the architecture. The problem is that architecture questions are hard to google.</p><p>A lot of what I learned came from conversations with other people in Ember community. To build those relationships takes time, so in many ways, Ember pays off if you invest time into learning how to do things in “Ember Way.”</p><p>ReactJS and AngularJS are not opinionated about how you should architect your application. They give you a way to render HTML to DOM and apply state changes. With these tools, you have to implement your architecture which can make it easier to make something work but can be risky if done incorrectly on large projects.</p><p>Angular on the other hand is a lot more opinionated than AngularJS. I suspect that experience of building with Angular will be more like Ember where it’ll be helpful to know how to do something in “Angular Way.”</p><p>One difference between Ember and Angular is that Ember’s configuration is implicit in the conventions. In Angular configuration is part of the development process, which makes the configuration more visible.</p><p>This comment is a long-winded response. Thank you for sharing your experience.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5c4de2275113" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Thanks Matt!]]></title>
            <link>https://medium.com/@tarasm/thanks-matt-420210b95f59?source=rss-eccf3ca48bae------2</link>
            <guid isPermaLink="false">https://medium.com/p/420210b95f59</guid>
            <dc:creator><![CDATA[Taras Mankovski]]></dc:creator>
            <pubDate>Thu, 27 Apr 2017 20:12:26 GMT</pubDate>
            <atom:updated>2017-04-27T20:12:26.181Z</atom:updated>
            <content:encoded><![CDATA[<p>Thanks Matt!</p><p>Say hi to the Ember contributor for me ;) I’m very excited about the value that cross polination can bring to all communities. It’s nice to have collaborators in this.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=420210b95f59" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Going to ng-conf as an Ember.js user]]></title>
            <link>https://medium.com/@tarasm/going-to-ng-conf-as-an-ember-js-user-212804ded0?source=rss-eccf3ca48bae------2</link>
            <guid isPermaLink="false">https://medium.com/p/212804ded0</guid>
            <category><![CDATA[angular]]></category>
            <category><![CDATA[angularjs]]></category>
            <category><![CDATA[angular2]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[ember]]></category>
            <dc:creator><![CDATA[Taras Mankovski]]></dc:creator>
            <pubDate>Wed, 26 Apr 2017 18:12:43 GMT</pubDate>
            <atom:updated>2017-04-26T20:53:36.312Z</atom:updated>
            <content:encoded><![CDATA[<p>I’ve been using and mentoring Ember.js exclusively for 3+ years. I went to EmberConf in 2014, 2015 and 2016. This year I decided to skip EmberConf and go to ng-conf instead.</p><p>This decision was made easier by the fact that <a href="https://medium.com/u/97e183b9e5ec">Tracy Lee | ladyleet</a> set me up to interview all of the ng-conf presenters for <a href="https://medium.com/u/caba78168cf0">This Dot Media</a>. It was a perfect opportunity to learn about what’s happening directly from people who’re on the cutting edge of Angular technology and community leadership.</p><p>The Angular community is in the middle of a major shift. Angular is a new framework that borrows many of the good ideas that made Angular.js popular and updates the toolset to include features that are standard in modern web applications development today.</p><p>The distinction between Angular and Angular.js in the previous paragraph is intentional. The Angular team is using Angular to refer to the Angular platform version 2.0 and above. Angular.js will be used for Angular pre version 2.0.</p><p>The new Angular has ahead of time(AoT) compiler which allows the templates to be compiled at build time, unlocks the ability to implement server side rendering, and improves performance of Angular applications. This was not possible with Angular.js and is a welcome improvement to the Angular platform.</p><p>In addition to compiling templates at build time, Angular added TypeScript as the primary scripting language. TypeScript gets transpiled down to regular JavaScript similarly to how Babel works in EmberCLI projects.</p><p>All of this built time work requires tooling that’s provided by the new Angular CLI. AngularCLI is a fork of EmberCLI with Webpack in-place of Broccoli. The Angular team used EmberCLI’s pod structure to implement Angular’s project hierarchy.</p><p>Files in an AngularCLI project are organized into component directories. Components are a concept that is fairly new in the Angular community. Components are a special kind of a Directive that has a controller and a template.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*X2QIdMStg1109S-UOm6Lug.png" /><figcaption>&lt;hero-detail&gt; Angular component written in TypeScript</figcaption></figure><p>If you squint, all of this looks and sounds similar to Ember. I think this speaks to the foresight that the Ember core team had and the emergent nature of the Ember framework.</p><p>When I started working with Ember in 2014, I was attracted to Ember Core Team’s focus on engineering and developer experience. I watched Yehuda Katz’ talks and was inspired by the dedication to giving developers the tools to be productive. This dedication lead to the creation of EmberCLI, which elevated the standard for frontend frameworks.</p><p>This year I saw the same dedication to developer experience at ng-conf in the keynote by the Angular Core team. In addition to annoucing all of the current features of AngularCLI, they announced their intention to isolate CLI internals into an SDK. The Angular SDK will make it possible for IDEs, like WebStorm and Visual Studio Code, to deeply integrate Angular CLI features into their development environments while allowing the Angular team to change the Angular platform without breaking compatibility. Angular CLI will become a wrapper around the Angular SDK.</p><p>Dedication to compatibility and providing an easy upgrade path is another area where Ember and Angular are now aligned. The Angular project adopted <a href="https://semver.org">Semver</a> which is the standard for communicating change in libraries. Angular team expressed their commitment to keeping backwards compatibility as they upgrade the Angular platform.</p><p>The Angular team is responsible for maintaining compatibility with close to a thousand(1000) Angular apps inside of Google. If a change breaks something unexpected, it will likely first break inside of Google before it’s released to the public.</p><p>While at the conference, I was hearing the same conversations about Angular that Ember community was having 2 years ago when EmberCLI was being created. The Angular community is just becoming familiar with AoT compilation which is something that Ember users have been taking for granted for a few years.</p><p>I counted 5 component library vendors at ng-conf, but only a few of them had native Angular components. Many of these component libraries have the 100+ options problem that Miguel Camba described in his <a href="https://vimeo.com/155779142">component composition</a> talks.</p><p>Ember community doesn’t have any component library vendors, that I know of, but Ember community has the benefit of having a stable and consistently evolving framework. We learned a lot about the limitations of building component trees with JavaScript and expanded the expressiveness of Glimmer templating engine to make component composition easier. We have few higher order components like <a href="http://www.ember-power-select.com">Ember Power Select</a> that most projects use that make component composition very easy.</p><p>One of the things that I found most surprising is how I thought that some things were only available in Ember. For as long as I used Ember, I was always excited for the prospect of Ember Engines becoming a reality. Engines promised the possibility of packaging applications as features that you can mount into an application. When Engines were ready, I was telling everyone about them because I thought it made Ember special. I was surprised that Angular has Modules which are part of the Angular application blueprint.</p><p>Another thing that I found surpising was that no-one knew anything about Ember.js. Some people thought that it was a view layer like React, but that’s like comparing a sewing machine to a needle. When I described Ember’s feature set, most people were surprised by how complete it is. Most developers at ng-conf that I spoke to never looked at Ember before choosing Angular.</p><p>It seems that for every new feature that Ember community added to Ember.js, we should have gone out and given a round of talks at non-Ember conferences to raise awareness.</p><p>I enjoyed my time in Angular community. The community is wonderful, diverse and welcoming. I made a lot of wonderful friends. Angular team is doing many things right and with Google’s backing will likely catch up in any area where it was delayed by Angular rewrite.</p><p>I’m very excited about Angular and the contribution that it will make to the evolution of the modern web ecosystem. It will set the new standard tooling in frontend development. Angular will make modern web development accessible to enterprise developers who have a high standard for tooling and enable a new generation of creators with the Angular platform.</p><p>It’s easy to think that “awesome” is wholy owned by your community when you never visit others. It also makes it difficult for others to learn about the things you love. Try going to someone else’s meetup this month, learn about others and share what you love.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=212804ded0" width="1" height="1">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Node.js microservices on Google App Engine]]></title>
            <link>https://medium.com/this-dot-labs/node-js-microservices-on-google-app-engine-b1193497fb4b?source=rss-eccf3ca48bae------2</link>
            <guid isPermaLink="false">https://medium.com/p/b1193497fb4b</guid>
            <category><![CDATA[nodejs]]></category>
            <category><![CDATA[google-app-engine]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[microservices]]></category>
            <category><![CDATA[deployment]]></category>
            <dc:creator><![CDATA[Taras Mankovski]]></dc:creator>
            <pubDate>Sun, 15 Jan 2017 19:35:09 GMT</pubDate>
            <atom:updated>2017-06-02T17:30:13.183Z</atom:updated>
            <content:encoded><![CDATA[<p>I spent the last three years doing exclusively frontend development with Ember.js. In the meantime, microservices became all the craze on the server land.</p><p>The difficulty of being a late adopter is that you have to learn everything right away to be able to use the tools effectively. On the bright side, many tools had time to go through a few iterations of improvements. Mature and better-integrated tooling makes learning much easier.</p><p>Google App Engine is one of the oldest PaaS providers. It’s backed by the Google Cloud which has an offering that’s very similar to Amazon AWS. GAE is the higher level abstraction over Google Cloud infrastructure that offers auto-scaling, managed deployment and microservices architecture.</p><p>GAE allows developers to compose complex applications from smaller microservices. Each microservice runs inside of it’s Docker container isolated from other microservices. A microservices driven application behaves like a regular web application. Between the user and the microservices sits a load balancer that routes user’s requests to a service for a particular URL.</p><p>This kind of architecture sounds amazing, very complicated and too difficult for most people to implement on their own. GAE gives all of this to you by default; you just need to know how to configure it.</p><p>I’m going to show you how to compose an app from multiple Node.js microservices. Before we begin, make sure to setup your computer by following <a href="https://cloud.google.com/nodejs/getting-started/hello-world#before-you-begin">Before you begin section on Quickstart for Node.js in the App Engine Flexible Environment page</a>.</p><h3>Part 1: Deploy main app to GAE</h3><ol><li>Run gcloud init to sign in to Google Cloud on your command line.</li><li>Create an empty directory with mkdir ~/node-microservices-example</li><li>Go into the directory with cd ~/node-microservices-example</li><li>Create a Google App Engine project with gcloud app create</li><li>Initialize a Node.js project with npm init</li></ol><p>So far, you’ll have a directory with only <em>package.json</em> in it. Next step is to modify your <em>package.json</em> to have all of the configurations that GAE needs to properly configure the app when it’s deployed.</p><p>6. Create <em>server.js</em> file. It’ll contain the code for the Node.js server that that’ll respond to all requests for this application.</p><p>7. Edit your <em>package.json</em> file to tell GAE how to start your server when it’s deployed. To do this, add <em>start</em> property to <em>scripts</em> hash.</p><pre>{<br>  ...<br>  &quot;scripts&quot;: {<br>    &quot;start&quot;: &quot;node server.js&quot;<br>  },<br>  ...<br>}</pre><p>GAE uses node start command to start the server. This command looks for <em>start</em> script. node server.js will execute server.js with node executable.</p><p>8. Let’s tell GAE to use Node.js 6 to run our server by specifying <em>engines</em> property in <em>package.json</em>.</p><pre>{<br>  ...<br>  &quot;engines&quot;: { <br>    &quot;node&quot; : &quot;&gt;=6.0.0&quot; <br>  },<br>  ...<br>}</pre><p>GAE uses <em>app.yaml</em> file as default entrypoint into your application. This file tells GAE the runtime to use for the project and the environment configuration.</p><p>9. Create <em>app.yaml</em> file with with <em>nodejs</em> runtime and <em>flex</em> environment.</p><pre>runtime: nodejs<br>env: flex </pre><p>10. Now, let’s create a simple <em>express</em> server in <em>server.js</em> that’ll respond to requests. Edit <em>server.js</em> and add the following code</p><pre>&quot;use strict&quot;; </pre><pre>const express = require(&#39;express&#39;); </pre><pre>const app = express(); </pre><pre>app.get(&#39;/&#39;, (req, res) =&gt; {    <br>   res.status(200).send(&#39;Hello world!&#39;);<br>});</pre><pre>app.listen(process.env.PORT);</pre><p>On the last line of the script app.listen(process.env.PORT);, we’re allowing the environment to specify the port that our server should be listen for incoming requests. By default, GAE routes requests to port 8080 and this port will be automatically provided to your server.</p><p>11. Before we deploy our application, we have to make sure that our app has the dependencies that it needs to run our application. We used <em>express</em> package so we need to install run npm install --save express to add <em>express</em> package to the dependencies in <em>package.json</em>.</p><p>In addition to everything that was generated by npm init , your <em>package.json</em> must have the following entries in it.</p><pre>{<br>  &quot;name&quot;: &quot;node-microservices-example&quot;,<br>  &quot;scripts&quot;: {<br>    &quot;start&quot;: &quot;node server.js&quot;<br>  },<br>  &quot;engines&quot;: {<br>    &quot;node&quot;: &quot;&gt;=6.0.0&quot;<br>  },<br>  &quot;dependencies&quot;: {<br>    &quot;express&quot;: &quot;4.14.0&quot;<br>  }<br>}</pre><p>12. Let’s deploy our app with gcloud app deploy.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/714/1*9UpW7082hjFoCM05AWtysw.gif" /></figure><p>13. After deploying you can see the result by running gcloud app browse. This will open the app in a browser.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Wq6-IeLTRrYb397YnxJNbw.png" /><figcaption>Hello world! is displayed in the app</figcaption></figure><p>So far we deployed an application to Google App Engine. This it the first app in our group of microservices. GAE calls this the <em>default</em> service. This app is the catch all for everything that’s not handled by other microservices.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qFGKd17g28DSdBBSK3OC2A.png" /></figure><p>Let’s add a microservice that’ll be responsible for admin section of our application.</p><h3>Part 2: Add first microservice</h3><p>We’ll create a new service called <em>admin</em> and we’ll route all traffic from /admin to this service. Each microservice is a separate application with its own dependencies and an <em>app.yaml</em> file. Routing requests to this microservice is done by configuring <em>dispatch.yaml</em> in our main application(ie <em>default</em> service).</p><ol><li>Let’s begin by creating a directory for our <em>admin</em> service. This directory can be anywhere but we’ll put it inside of our node-microservices-example directory for convenience. mkdir ~/node-microservices-example/admin</li><li>Your <em>admin</em> application has to be complete on it’s own. It must have a <em>package.json</em> file with it’s own start script, engines property and it’s own dependencies. Follow steps 5–8 from part 1 for directions.</li><li>To tell GAE that you’re creating another service, you must provide a service name in the <em>app.yaml</em> file of your microservice.</li></ol><pre>env: flex<br>runtime: nodejs<br>service: admin</pre><p>app.yaml does not need to be called app.yaml. You could call it admin.yaml as long as service: admin property is set, GAE will know that you’re deploying a microservice and not the <em>default</em> service. Using app.yaml makes it possible to run gcloud app deploy inside of <em>admin</em> directory and gcloud command will look for app.yaml automatically.</p><p>4. Create a server.js for the <em>admin</em> section.</p><pre>&quot;use strict&quot;; </pre><pre>const express = require(&#39;express&#39;); </pre><pre>const app = express(); </pre><pre>app.get(&#39;/&#39;, (req, res) =&gt; {    <br>   res.status(200).send(&#39;Admin Section&#39;);<br>});</pre><pre>app.listen(process.env.PORT);</pre><p>5. We’re not done yet, but let’s deploy this service to see what happens. To deploy a microservice, you can run gcloud app deploy inside of the microservice’s directory or gcloud app deploy admin/app.yaml from main app’s directory.</p><p>6. If you run gcloud app browse -s admin, a browser window will open on a subdomain of your <em>default</em> service’s url. Every service automatically get’s a subdomain that can be accessed by going to the url.</p><p>7. We want our <em>admin</em> service to be accessible from /admin url instead of the subdomain. We can configure routing for our <em>default</em> app by creating a dispatch.yaml file.</p><pre>dispatch:<br>  - url: &#39;*/admin&#39;<br>    module: admin<br></pre><p>8. The dispatch configuration tells GAE how to route requests inside of your application. It doesn’t do any rewriting of urls. So our server must explicitely listen to requests on /admin. Let’s modify <em>admin/server.js</em> to handle /admin url.</p><pre>&quot;use strict&quot;;</pre><pre>const express = require(&#39;express&#39;);</pre><pre>const app = express();</pre><pre>app.get(&#39;/admin&#39;, (req, res) =&gt; {    <br>   res.status(200).send(&#39;Admin Section&#39;);<br>});</pre><pre>app.listen(process.env.PORT);</pre><p>9. Let’s deploy our updated <em>admin</em> service and routing configuration by running gcloud app deploy admin/app.yaml dispatch.yaml</p><p>Now you have an app that is composed of two apps. The <em>main</em> app that’s served by the default service and <em>admin</em> app served by admin service. GAE will automatically handle routing requests from /admin url to the admin service and these services run in isolation from each other in their own containers.</p><p>Code for this application is available on <a href="https://github.com/taras/gae-node-microservices-example/tree/walk-through">GitHub</a>. Follow me to learn more about building applications with Google App Engine.</p><p>Please, leave me a comment if you found this article useful. You can also tell me what you would like to learn next.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b1193497fb4b" width="1" height="1"><hr><p><a href="https://medium.com/this-dot-labs/node-js-microservices-on-google-app-engine-b1193497fb4b">Node.js microservices on Google App Engine</a> was originally published in <a href="https://medium.com/this-dot-labs">This Dot Labs</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[I agree with every point in this blog post except for “Bad Ember developers return RSVP.hash]]></title>
            <link>https://medium.com/@tarasm/i-agree-with-every-point-in-this-blog-post-except-for-bad-ember-developers-return-rsvp-hash-9acde3239c8?source=rss-eccf3ca48bae------2</link>
            <guid isPermaLink="false">https://medium.com/p/9acde3239c8</guid>
            <dc:creator><![CDATA[Taras Mankovski]]></dc:creator>
            <pubDate>Tue, 16 Aug 2016 15:17:01 GMT</pubDate>
            <atom:updated>2016-08-16T15:17:01.721Z</atom:updated>
            <content:encoded><![CDATA[<p>I agree with every point in this blog post except for “Bad Ember developers return <em>RSVP.hash</em> or <em>RSVP.all</em>.”?</p><p>Why do you think this is the case?</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9acde3239c8" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>`;

exports.parse = function(url) {
  return payload;
}